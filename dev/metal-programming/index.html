<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Metal Programming in Julia · Metal.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://metal.juliagpu.org/stable/metal-programming/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Metal.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Metal.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../api/essentials/">Essentials</a></li><li><a class="tocitem" href="../api/compiler/">Compiler</a></li><li><a class="tocitem" href="../api/kernel/">Kernel programming</a></li><li><a class="tocitem" href="../api/array/">Array programming</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../usage/overview/">Overview</a></li><li><a class="tocitem" href="../usage/array/">Array programming</a></li></ul></li><li><a class="tocitem" href="../profiling/">Profiling</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction to Metal Programming in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Metal Programming in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/Metal.jl/blob/main/docs/src/metal-programming.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-Metal-Programming-in-Julia"><a class="docs-heading-anchor" href="#Introduction-to-Metal-Programming-in-Julia">Introduction to Metal Programming in Julia</a><a id="Introduction-to-Metal-Programming-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Metal-Programming-in-Julia" title="Permalink"></a></h1><p><em>A quick and dirty introduction to GPU programming on MacOS</em></p><h2 id="High-Level-Array-Operations"><a class="docs-heading-anchor" href="#High-Level-Array-Operations">High-Level Array Operations</a><a id="High-Level-Array-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Array-Operations" title="Permalink"></a></h2><p>This document isn&#39;t meant to cover the high-level array operations that Metal.jl enables. Performing <code>Array</code> operations on <code>MtlArrays</code> should <em>just work</em> if the types are compatible. For example, <code>gpu_c .= gpu_a .+ gpu_b</code> Thus, this document is more about an introduction to explicit GPU <em>kernel</em> programming.</p><h2 id="Kernel-Programming"><a class="docs-heading-anchor" href="#Kernel-Programming">Kernel Programming</a><a id="Kernel-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-Programming" title="Permalink"></a></h2><p>Metal.jl is based off of Apple&#39;s <a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shading Language (MSL)</a> and Metal framework. The interface allows you to utilize the graphics and computing power of Mac GPUs. Like many other GPU frameworks, its history is rooted in graphics processing but has found use in computing/general purpose GPU (GPGPU) applications.</p><p>The most fundamental idea of programming GPUs (when compared to serial CPU programming) is its <em>parallelism</em>. A GPU function (kernel), when called, is not just ran once in isolation. Rather, numerous (often thousands to millions) psuedo-independent instances (called threads) of the kernel are executed in parallel. These threads are arranged in a hierarchy that allows for varying levels of synchronization. For Metal, the hierarchy is as follows:</p><ul><li>Thread: A single execution unit of the kernel</li><li>Threadgroup: A collection of threads that share a common block of memory and synchronization</li></ul><p>barriers</p><ul><li>Grid: A collection of threadgroups</li></ul><p>The threadgroup and grid sizes are set by the user when launching the GPU kernel. There are upper limits determined by the targeted hardware, and the sizes can be 1, 2, or 3-dimensional. For Metal.jl, these sizes are set using the <code>@metal</code> macro&#39;s keyword arguments. The <code>grid</code> keyword determines the grid size while the <code>threads</code> keyword determines the threadgroup size.</p><p>For example, given a 10x10x3 image that you want to run a function independently on each pixel, the kernel launch code might look like the following: <code>@metal threads=(10,10) groups=3 my_kernel(gpu_image_array)</code> This would launch 3 separate threadgroups of 100 threads each (10 in the first dimension and 10 in the second dimension)</p><p>There is also additional hierarchy layers that consists of small groups of threads that execute in lockstep called <em>waves/SIMD groups/</em>wavefronts* and <em>quadgroups</em>. However, the basic three-tier hierarchy is enough to get started.</p><p><a href="https://developer.apple.com/documentation/metal/compute_passes/creating_threads_and_threadgroups?language=objc">Here</a> is a helpful link with good visualizations of Metal&#39;s thread hierarchy (also covering SIMD groups).</p><p>Each thread has its own set of private variables. Most importantly, each thread has associated unique indices to identify itself within its threadgroup and grid. These are traditionally what are used to differentiate execution across threads. You can also query what the grid and threadgroup sizes are as well.</p><p>For Metal.jl, these values are accessed via the following functions:</p><ul><li>thread<em>index</em>in_threadgroup()</li><li>grid<em>size</em>Xd()</li><li>thread<em>position</em>in<em>grid</em>Xd()</li><li>thread<em>position</em>in<em>threadgroup</em>Xd()</li><li>threadgroup<em>position</em>in<em>grid</em>Xd()</li><li>threadgroups<em>per</em>grid_Xd()</li><li>threads<em>per</em>grid_Xd()</li><li>threads<em>per</em>threadgroup_Xd()</li></ul><p><em>Where &#39;X&#39; is 1, 2, or 3 according to the number of dimensions requested.</em></p><p>Using these in a kernel (taken directly from the <a href="../../../examples/vadd.jl">vadd example</a>):</p><pre><code class="language-julia hljs">function vadd(a, b, c)
    i = thread_position_in_grid_1d()
    c[i] = a[i] + b[i]
    return
end</code></pre><p>This kernel takes in three vectors (a,b,c) all of the same length and stores the element-wise sum of <code>a</code> and <code>b</code> into <code>c</code>. Each thread in this kernel gets its unique position in the grid (arrangement of all threadgroups) and stores this value into the variable <code>i</code> which is then used as the index into the vectors. Thus, each thread is computing one sum and storing the result in the output vector.</p><p>To ensure this kernel functions properly, we have to launch it with exactly as many threads as the length of the vectors. If we under or over-launch threads, the result could be incorrect.</p><p>An example of a good launch:</p><pre><code class="language-julia hljs">len = prod(size(d_a))
@metal threads=len vadd(d_a, d_b, d_c)</code></pre><p>Additional notes:</p><ul><li>Kernels must always return nothing</li><li>Kernels are asynchronous. To synchronize, use the <code>Metal.@sync</code> macro.</li></ul><h2 id="Other-Helpful-Links"><a class="docs-heading-anchor" href="#Other-Helpful-Links">Other Helpful Links</a><a id="Other-Helpful-Links-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Helpful-Links" title="Permalink"></a></h2><p><a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shading Language Specification</a> <a href="https://wiki.illinois.edu/wiki/display/ECE408/Materials+from+prior+semesters">An Introduction to GPU Programming course from University of Illinois</a> (primarily in CUDA, but the concepts are transferable)</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 26 June 2023 04:07">Monday 26 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
