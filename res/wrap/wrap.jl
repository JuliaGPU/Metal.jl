# Not necessary, but removes some errors that don't seem to affect the output
using Clang_jll
Clang_jll.libclang = "/Applications/Xcode.app/Contents/Frameworks/libclang.dylib"

using Clang.Generators
using Clang.Generators: LinkEnumAlias
using Clang
using Glob
using JuliaFormatter
using Logging

# Use system SDK
SDK_PATH = `xcrun --show-sdk-path` |> open |> readchomp |> String

# Hack to prevent printing of functions for now
Generators.skip_check(dag::Generators.ExprDAG, node::Generators.ExprNode{Generators.FunctionProto}) = true

main(name::AbstractString; kwargs...) = main([name]; kwargs...)
function main(names=["all"]; sdk_path=SDK_PATH)
    path_to_framework(framework) = joinpath(sdk_path, "System/Library/Frameworks/",framework*".framework","Headers")
    path_to_mps_framework(framework) = joinpath(sdk_path, "System/Library/Frameworks/","MetalPerformanceShaders.framework","Frameworks",framework*".framework","Headers")

    defines = []

    ctxs = []

    if "all" in names
        names = ["all"]
    end

    for name in names
        if name == "all" || name == "libmtl" || name == "mtl"
            fwpath = path_to_framework("Metal")
            tctx = wrap("libmtl", joinpath(fwpath, "Metal.h"); targets=glob("*.h", fwpath), defines,
                include_dirs=[fwpath])
            push!(ctxs, tctx)
        end

        if name == "all" || name == "libmps" || name == "mps"
            mpsframeworks = ["MPSCore", "MPSImage", "MPSMatrix", "MPSNDArray", "MPSNeuralNetwork", "MPSRayIntersector"]
            fwpaths = [path_to_framework("MetalPerformanceShaders")]
            fwpaths = append!(fwpaths, path_to_mps_framework.(mpsframeworks))

            getheaderfname(path) = Sys.splitext(Sys.splitpath(path)[end-1])[1] * ".h"
            headers = joinpath.(fwpaths, getheaderfname.(fwpaths))

            tctx = wrap("libmps", headers; defines,
                include_dirs=fwpaths)
            push!(ctxs, tctx)
        end

        # if name == "all" || name == "libfoundation" || name == "foundation"
        #     fwpath = path_to_framework("Foundation")
        #     tctx = wrap("libfoundation", joinpath(foundation, "Foundation.h"); targets=glob("*.h", fwpath), defines=["__builtin_va_list"],
        #         include_dirs=[fwpath])
        #     push!(ctxs, tctx)
        # end
        # if name == "all" || name == "libcf" || name == "cf"
        #     fwpath = path_to_framework("CoreFoundation")
        #     tctx = wrap("libfoundation", joinpath(fwpath, "CoreFoundation.h"); targets=glob("*.h", fwpath), defines=["__builtin_va_list"],
        #         include_dirs=[fwpath])
        #     push!(ctxs, tctx)
        # end
    end
    return ctxs
end

function wrap(name, headers; targets=headers, defines=[], include_dirs=[], precomp_header=nothing)
    @info "Wrapping $name"

    options = load_options(joinpath(@__DIR__, "$(name).toml"))

    args = [
        "-x","objective-c",
        "-isysroot", SDK_PATH,
        "-fblocks",
        "-fregister-global-dtors-with-atexit",
        "-fgnuc-version=4.2.1",
        "-fobjc-runtime=macosx-15.0.0",
        "-fobjc-exceptions",
        "-fexceptions",
        "-fmax-type-align=16",
        "-fcommon",
        "-DNS_FORMAT_ARGUMENT(A)=",
        "-D__GCC_HAVE_DWARF2_CFI_ASM=1",
        ]

    for define in defines
        if isa(define, Pair)
            append!(args, ["-D", "$(first(define))=$(last(define))"])
        else
            append!(args, ["-D", "$define"])
        end
    end

    @info "Creating context"
    ctx = create_objc_context(headers, args, options)

    @info "Building no printing"
    build!(ctx, BUILDSTAGE_NO_PRINTING)

    rewriter!(ctx, options)

    @info "Building only printing"
    build!(ctx, BUILDSTAGE_PRINTING_ONLY)

    output_file = options["general"]["output_file_path"]

    # prepend "autogenerated, do not edit!" comment
    output_data = read(output_file, String)
    open(output_file, "w") do io
        println(io, """# This file is automatically generated. Do not edit!
                       # To re-generate, execute res/wrap/wrap.jl""")
        println(io)
        print(io, output_data)
    end

    format_file(output_file, YASStyle())

    return ctx
end

# Uses the same passes as with C, but with some other changes
create_objc_context(header::AbstractString, args=String[], ops=Dict()) = create_objc_context([header], args, ops)
function create_objc_context(headers::Vector, args::Vector=String[], options::Dict=Dict())
    system_dirs = [
                    SDK_PATH,
                    "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain"
                  ]

    # Since the framework we're wrapping is a system header,
    # find all dependent headers, then remove all but the relevant ones
    # also temporarily disable logging
    Base.CoreLogging._min_enabled_level[] = Logging.Info+1
    dependent_headers = let
        all_headers = find_dependent_headers(headers,args,[])
        dep_headers = Vector{eltype(all_headers)}(undef, 0)
        for header in headers
            target_framework = "/"*joinpath(Sys.splitpath(header)[end-2:end-1])
            dep_headers = append!(dep_headers, filter(s -> occursin(target_framework, s), all_headers))
        end
        dep_headers
    end
    Base.CoreLogging._min_enabled_level[] = Logging.Debug

    ctx = Context(; options)

    @info "Parsing headers..."
    parse_headers!(ctx, headers, args)

    Generators.add_default_passes!(ctx, options, system_dirs, dependent_headers)

    # push!(ctx.passes, CollectTopLevelNode(ctx.trans_units, dependent_headers, system_dirs))
    # push!(ctx.passes, LinkTypedefToAnonymousTagType())
    # push!(ctx.passes, LinkTypedefToAnonymousTagType(is_system=true))
    # push!(ctx.passes, IndexDefinition())
    # push!(ctx.passes, CollectDependentSystemNode())
    # push!(ctx.passes, IndexDefinition())
    # push!(ctx.passes, CollectNestedRecord())
    # push!(ctx.passes, FindOpaques())
    # push!(ctx.passes, ResolveDependency(info=false))
    # push!(ctx.passes, RemoveCircularReference())
    # push!(ctx.passes, TopologicalSort())
    # push!(ctx.passes, IndexDefinition())
    # push!(ctx.passes, ResolveDependency())
    # push!(ctx.passes, CatchDuplicatedAnonymousTags())
    # push!(ctx.passes, CodegenPreprocessing())

    # general_options = get(options, "general", Dict())
    # if get(general_options, "smart_de_anonymize", true)
    #     push!(ctx.passes, DeAnonymize())
    # end
    # if get(general_options, "no_audit", false)
    #     @error "The generator is running in `no_audit` mode. It could generate invalid Julia code. You can remove the `no_audit` entry in the `.toml` file to exit this mode."
    #     get(general_options, "link_enum_alias", true) && push!(ctx.passes, LinkEnumAlias())
    # else
    #     push!(ctx.passes, Audit())
    # end
    # push!(ctx.passes, Codegen())
    # push!(ctx.passes, CodegenMacro())

    # if get(general_options, "add_fptr_methods", false)
    #     push!(ctx.passes, AddFPtrMethods())
    # end
    # if get(general_options, "auto_mutability", false)
    #     push!(ctx.passes, TweakMutability())
    # end

    # # support old behavior
    # api_file = get(general_options, "output_api_file_path", "")
    # common_file = get(general_options, "output_common_file_path", "")

    # output_file_path = get(general_options, "output_file_path", "")

    # if isempty(api_file) && isempty(common_file)
    #     if !isempty(output_file_path)
    #         push!(ctx.passes, ProloguePrinter(output_file_path))
    #         push!(ctx.passes, GeneralPrinter(output_file_path))
    #         push!(ctx.passes, EpiloguePrinter(output_file_path))
    #     else
    #         # print to stdout if there is no `output_file_path`
    #         # this is handy when playing in REPL
    #         push!(ctx.passes, StdPrinter())
    #     end
    # else
    #     # let the user handle prologue and epilogue on their own
    #     push!(ctx.passes, FunctionPrinter(api_file))
    #     push!(ctx.passes, CommonPrinter(common_file))
    # end

    # return ctx
end

function rewriter!(ctx, options)
    if haskey(options, "api")
        for node in get_nodes(ctx.dag)
            if typeof(node) <: Generators.ExprNode{<:Generators.AbstractStructNodeType}
                expr = node.exprs[1]
                structName = String(expr.args[2])

                if haskey(options["api"], structName)
                    # Add default constructer to some structs
                    if haskey(options["api"][structName], "constructor")
                        expr = node.exprs[1]
                        con = options["api"][structName]["constructor"] |> Meta.parse

                        if con.head == :(=) && con.args[2] isa Expr && con.args[2].head == :block &&
                            con.args[2].args[1] isa LineNumberNode && con.args[2].args[2].head == :call
                            con.args[2] = con.args[2].args[2]
                        end
                        push!(expr.args[3].args, con)
                    end
                end
            end
        end
    end
end

if abspath(PROGRAM_FILE) == @__FILE__
    main()
end
